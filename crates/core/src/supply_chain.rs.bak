//! Supply Chain Security Module
//!
//! This module implements supply chain security measures including SBOM generation,
//! cryptographic signatures, provenance tracking, and dependency pinning.
//! It also includes artifact integrity features with Sigstore/cosign signing
//! and dependency trust features for SCA, pinning, and verification.

use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::fmt;
use std::sync::atomic::{AtomicU64, Ordering};
use std::sync::Arc;

/// Represents a Software Bill of Materials (SBOM)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Sbom {
    /// Unique identifier for the SBOM
    pub id: String,
    /// Name of the software component
    pub name: String,
    /// Version of the software component
    pub version: String,
    /// List of components in the SBOM
    pub components: Vec<Component>,
    /// Timestamp of SBOM creation
    pub created: u64,
    /// Hash of the SBOM content
    pub hash: String,
}

/// Represents a software component in an SBOM with additional trust information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Component {
    /// Unique identifier for the component
    pub id: String,
    /// Name of the component
    pub name: String,
    /// Version of the component
    pub version: String,
    /// Package URL (purl) of the component
    pub purl: String,
    /// License information
    pub licenses: Vec<String>,
    /// Hash of the component
    pub hash: String,
    /// Whether this is a direct dependency
    pub is_direct: bool,
    /// List of vulnerabilities associated with this component
    pub vulnerabilities: Vec<Vulnerability>,
    /// Whether the component version is pinned
    pub is_pinned: bool,
    /// Whether the component checksum has been verified
    pub checksum_verified: bool,
    /// Whether the component is approved for use
    pub is_approved: bool,
}

/// Represents a vulnerability in a component
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vulnerability {
    /// Unique identifier for the vulnerability (e.g., CVE ID)
    pub id: String,
    /// Severity rating (CVSS score)
    pub severity: f32,
    /// Description of the vulnerability
    pub description: String,
    /// Whether a fix is available
    pub fix_available: bool,
}

/// Represents a cryptographic signature
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Signature {
    /// Signature algorithm used
    pub algorithm: String,
    /// Public key used for verification
    pub public_key: String,
    /// Signature value
    pub signature: String,
    /// Timestamp of signature creation
    pub timestamp: u64,
}

/// Represents provenance information for a build
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Provenance {
    /// Unique identifier for the provenance record
    pub id: String,
    /// Build ID
    pub build_id: String,
    /// Source repository information
    pub source: SourceInfo,
    /// Build configuration
    pub build_config: BuildConfig,
    /// Builder information
    pub builder: BuilderInfo,
    /// Artifacts produced by the build
    pub artifacts: Vec<Artifact>,
    /// Timestamp of provenance creation
    pub created: u64,
}

/// Represents source repository information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SourceInfo {
    /// Repository URL
    pub repo_url: String,
    /// Commit hash
    pub commit_hash: String,
    /// Branch name
    pub branch: String,
    /// Tag name (if applicable)
    pub tag: Option<String>,
}

/// Represents build configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BuildConfig {
    /// Build script or configuration file
    pub build_script: String,
    /// Environment variables
    pub environment: HashMap<String, String>,
    /// Build tools and versions
    pub tools: HashMap<String, String>,
}

/// Represents builder information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BuilderInfo {
    /// Builder ID
    pub id: String,
    /// Builder version
    pub version: String,
    /// Builder platform
    pub platform: String,
}

/// Represents an artifact with integrity information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Artifact {
    /// Artifact name
    pub name: String,
    /// Artifact URI
    pub uri: String,
    /// Hash of the artifact
    pub hash: String,
    /// Size of the artifact in bytes
    pub size: u64,
    /// Cryptographic signature (if signed)
    pub signature: Option<Signature>,
    /// SBOM attached to the artifact
    pub sbom: Option<Sbom>,
    /// Whether the artifact is signed with Sigstore/cosign
    pub is_signed: bool,
    /// Timestamp of artifact creation
    pub created: u64,
}

/// Represents Sigstore/cosign signing information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CosignSignature {
    /// Signature payload
    pub payload: String,
    /// Signature value
    pub signature: String,
    /// Certificate used for signing
    pub certificate: String,
    /// Timestamp of signature creation
    pub timestamp: u64,
}

/// Artifact integrity statistics
#[derive(Debug, Clone)]
pub struct ArtifactIntegrityStats {
    /// Total artifacts processed
    pub total_artifacts: Arc<AtomicU64>,
    /// Unsigned artifacts blocked
    pub unsigned_blocked: Arc<AtomicU64>,
    /// Signed artifacts verified
    pub signed_verified: Arc<AtomicU64>,
    /// Failed signature verifications
    pub signature_failures: Arc<AtomicU64>,
}

/// Dependency trust statistics
#[derive(Debug, Clone)]
pub struct DependencyTrustStats {
    /// Total dependencies checked
    pub total_dependencies: Arc<AtomicU64>,
    /// Unapproved dependency install attempts blocked
    pub unapproved_blocked: Arc<AtomicU64>,
    /// Typosquat packages detected
    pub typosquat_detected: Arc<AtomicU64>,
    /// Checksum verification failures
    pub checksum_failures: Arc<AtomicU64>,
}

/// CI/CD gatekeeping statistics
#[derive(Debug, Clone)]
pub struct CicdGatekeepingStats {
    /// Total builds processed
    pub total_builds: Arc<AtomicU64>,
    /// Builds blocked by policy gate
    pub builds_blocked: Arc<AtomicU64>,
    /// Security scans performed
    pub security_scans: Arc<AtomicU64>,
    /// Tests executed
    pub tests_executed: Arc<AtomicU64>,
}

/// Represents a CI/CD policy rule
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PolicyRule {
    /// Unique identifier for the policy rule
    pub id: String,
    /// Name of the policy rule
    pub name: String,
    /// Description of the policy rule
    pub description: String,
    /// Whether the rule is enabled
    pub enabled: bool,
    /// Severity level of the rule
    pub severity: String, // "low", "medium", "high", "critical"
    /// Category of the rule
    pub category: String, // "security", "license", "quality", "compliance"
}

/// Represents a build with CI/CD policy enforcement
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Build {
    /// Unique identifier for the build
    pub id: String,
    /// Build number
    pub build_number: String,
    /// Source repository information
    pub source: SourceInfo,
    /// Build configuration
    pub config: BuildConfig,
    /// Artifacts produced by the build
    pub artifacts: Vec<Artifact>,
    /// Policy rules that were evaluated
    pub policy_rules: Vec<PolicyRule>,
    /// Results of policy evaluations
    pub policy_results: HashMap<String, bool>, // rule_id -> passed
    /// Timestamp of build creation
    pub created: u64,
    /// Whether the build passed all policies
    pub passed_policies: bool,
}

/// Represents a security scan result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SecurityScanResult {
    /// Unique identifier for the scan
    pub id: String,
    /// Build ID this scan is for
    pub build_id: String,
    /// Type of scan performed
    pub scan_type: String, // "sast", "sca", "container", "infrastructure"
    /// Vulnerabilities found
    pub vulnerabilities: Vec<Vulnerability>,
    /// Licenses found
    pub licenses: Vec<String>,
    /// Timestamp of scan completion
    pub completed: u64,
    /// Whether the scan passed policy requirements
    pub passed: bool,
}

/// Represents a test result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestResult {
    /// Unique identifier for the test
    pub id: String,
    /// Build ID this test is for
    pub build_id: String,
    /// Type of test performed
    pub test_type: String, // "unit", "integration", "e2e", "performance"
    /// Number of tests executed
    pub tests_executed: u64,
    /// Number of tests passed
    pub tests_passed: u64,
    /// Number of tests failed
    pub tests_failed: u64,
    /// Test coverage percentage
    pub coverage: f32,
    /// Timestamp of test completion
    pub completed: u64,
    /// Whether the tests passed policy requirements
    pub passed: bool,
}

/// Custom error type for supply chain operations
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum SupplyChainError {
    /// SBOM generation failed
    SbomGenerationFailed(String),
    /// Signature verification failed
    SignatureVerificationFailed(String),
    /// Provenance validation failed
    ProvenanceValidationFailed(String),
    /// Dependency scanning failed
    DependencyScanFailed(String),
    /// Configuration error
    ConfigurationError(String),
    /// Dependency trust validation failed
    DependencyTrustValidationFailed(String),
    /// CI/CD policy validation failed
    CicdPolicyValidationFailed(String),
}

impl fmt::Display for SupplyChainError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            SupplyChainError::SbomGenerationFailed(msg) => {
                write!(f, "SBOM generation failed: {}", msg)
            }
            SupplyChainError::SignatureVerificationFailed(msg) => {
                write!(f, "Signature verification failed: {}", msg)
            }
            SupplyChainError::ProvenanceValidationFailed(msg) => {
                write!(f, "Provenance validation failed: {}", msg)
            }
            SupplyChainError::DependencyScanFailed(msg) => {
                write!(f, "Dependency scan failed: {}", msg)
            }
            SupplyChainError::ConfigurationError(msg) => write!(f, "Configuration error: {}", msg),
            SupplyChainError::DependencyTrustValidationFailed(msg) => {
                write!(f, "Dependency trust validation failed: {}", msg)
            }
            SupplyChainError::CicdPolicyValidationFailed(msg) => {
                write!(f, "CI/CD policy validation failed: {}", msg)
            }
        }
    }
}

impl std::error::Error for SupplyChainError {}

/// Manages supply chain security operations
pub struct SupplyChainManager {
    /// SBOM storage
    pub sboms: HashMap<String, Sbom>,
    /// Signature storage
    pub signatures: HashMap<String, Signature>,
    /// Provenance storage
    pub provenance: HashMap<String, Provenance>,
    /// Cosign signatures
    pub cosign_signatures: HashMap<String, CosignSignature>,
    /// Artifact integrity statistics
    pub integrity_stats: ArtifactIntegrityStats,
    /// Dependency trust statistics
    pub trust_stats: DependencyTrustStats,
    /// CI/CD gatekeeping statistics
    pub cicd_stats: CicdGatekeepingStats,
    /// Approved dependencies list
    pub approved_dependencies: HashMap<String, String>, // name -> version regex
    /// Known typosquat packages
    pub typosquat_packages: HashMap<String, String>, // suspicious name -> legitimate name
    /// Policy rules
    pub policy_rules: HashMap<String, PolicyRule>,
    /// Builds
    pub builds: HashMap<String, Build>,
    /// Security scan results
    pub security_scans: HashMap<String, SecurityScanResult>,
    /// Test results
    pub test_results: HashMap<String, TestResult>,
}

impl SupplyChainManager {
    /// Create a new supply chain manager
    pub fn new() -> Self {
        let mut manager = Self {
            sboms: HashMap::new(),
            signatures: HashMap::new(),
            provenance: HashMap::new(),
            cosign_signatures: HashMap::new(),
            integrity_stats: ArtifactIntegrityStats {
                total_artifacts: Arc::new(AtomicU64::new(0)),
                unsigned_blocked: Arc::new(AtomicU64::new(0)),
                signed_verified: Arc::new(AtomicU64::new(0)),
                signature_failures: Arc::new(AtomicU64::new(0)),
            },
            trust_stats: DependencyTrustStats {
                total_dependencies: Arc::new(AtomicU64::new(0)),
                unapproved_blocked: Arc::new(AtomicU64::new(0)),
                typosquat_detected: Arc::new(AtomicU64::new(0)),
                checksum_failures: Arc::new(AtomicU64::new(0)),
            },
            cicd_stats: CicdGatekeepingStats {
                total_builds: Arc::new(AtomicU64::new(0)),
                builds_blocked: Arc::new(AtomicU64::new(0)),
                security_scans: Arc::new(AtomicU64::new(0)),
                tests_executed: Arc::new(AtomicU64::new(0)),
            },
            approved_dependencies: HashMap::new(),
            typosquat_packages: HashMap::new(),
            policy_rules: HashMap::new(),
            builds: HashMap::new(),
            security_scans: HashMap::new(),
            test_results: HashMap::new(),
        };
        
        // Initialize with some default approved dependencies and known typosquat packages
        manager.initialize_default_approvals();
        manager.initialize_typosquat_detection();
        manager.initialize_default_policies();
        
        manager
    }
    
    /// Initialize default approved dependencies
    fn initialize_default_approvals(&mut self) {
        // In a real implementation, this would be loaded from a configuration file
        self.approved_dependencies.insert("serde".to_string(), r"^1\.[0-9]+\.[0-9]+$".to_string());
        self.approved_dependencies.insert("tokio".to_string(), r"^1\.[0-9]+\.[0-9]+$".to_string());
        self.approved_dependencies.insert("axum".to_string(), r"^0\.[0-9]+\.[0-9]+$".to_string());
    }
    
    /// Initialize known typosquat packages for detection
    fn initialize_typosquat_detection(&mut self) {
        // In a real implementation, this would be loaded from a security database
        self.typosquat_packages.insert("serede".to_string(), "serde".to_string());
        self.typosquat_packages.insert("tokioo".to_string(), "tokio".to_string());
        self.typosquat_packages.insert("axun".to_string(), "axum".to_string());
    }
    
    /// Initialize default policy rules
    fn initialize_default_policies(&mut self) {
        // Security policies
        self.policy_rules.insert(
            "security-scan-required".to_string(),
            PolicyRule {
                id: "security-scan-required".to_string(),
                name: "Security Scan Required".to_string(),
                description: "All builds must pass security scanning".to_string(),
                enabled: true,
                severity: "high".to_string(),
                category: "security".to_string(),
            }
        );
        
        self.policy_rules.insert(
            "no-critical-vulns".to_string(),
            PolicyRule {
                id: "no-critical-vulns".to_string(),
                name: "No Critical Vulnerabilities".to_string(),
                description: "Builds must not contain critical vulnerabilities".to_string(),
                enabled: true,
                severity: "critical".to_string(),
                category: "security".to_string(),
            }
        );
        
        // License policies
        self.policy_rules.insert(
            "approved-licenses-only".to_string(),
            PolicyRule {
                id: "approved-licenses-only".to_string(),
                name: "Approved Licenses Only".to_string(),
                description: "Only approved licenses are allowed".to_string(),
                enabled: true,
                severity: "medium".to_string(),
                category: "license".to_string(),
            }
        );
        
        // Quality policies
        self.policy_rules.insert(
            "minimum-test-coverage".to_string(),
            PolicyRule {
                id: "minimum-test-coverage".to_string(),
                name: "Minimum Test Coverage".to_string(),
                description: "Builds must meet minimum test coverage requirements".to_string(),
                enabled: true,
                severity: "medium".to_string(),
                category: "quality".to_string(),
            }
        );
        
        self.policy_rules.insert(
            "all-tests-must-pass".to_string(),
            PolicyRule {
                id: "all-tests-must-pass".to_string(),
                name: "All Tests Must Pass".to_string(),
                description: "All tests must pass before deployment".to_string(),
                enabled: true,
                severity: "high".to_string(),
                category: "quality".to_string(),
            }
        );
        
        // Compliance policies
        self.policy_rules.insert(
            "dependency-trust-check".to_string(),
            PolicyRule {
                id: "dependency-trust-check".to_string(),
                name: "Dependency Trust Check".to_string(),
                description: "All dependencies must be trusted".to_string(),
                enabled: true,
                severity: "high".to_string(),
                category: "compliance".to_string(),
            }
        );
    }

    /// Generate an SBOM for a software component
    pub fn generate_sbom(&self, name: &str, version: &str) -> Result<Sbom, SupplyChainError> {
        // In a real implementation, this would scan the project dependencies
        // and generate a comprehensive SBOM. For this example, we'll create
        // a simple placeholder SBOM.

        let components = vec![
            Component {
                id: "component-1".to_string(),
                name: "serde".to_string(),
                version: "1.0.130".to_string(),
                purl: "pkg:cargo/serde@1.0.130".to_string(),
                licenses: vec!["MIT".to_string(), "Apache-2.0".to_string()],
                hash: "sha256:abcd1234...".to_string(),
                is_direct: true,
                vulnerabilities: vec![],
                is_pinned: true,
                checksum_verified: true,
                is_approved: true,
            },
            Component {
                id: "component-2".to_string(),
                name: "tokio".to_string(),
                version: "1.15.0".to_string(),
                purl: "pkg:cargo/tokio@1.15.0".to_string(),
                licenses: vec!["MIT".to_string()],
                hash: "sha256:efgh5678...".to_string(),
                is_direct: true,
                vulnerabilities: vec![],
                is_pinned: true,
                checksum_verified: true,
                is_approved: true,
            },
        ];

        let sbom = Sbom {
            id: format!("sbom-{}-{}", name, version),
            name: name.to_string(),
            version: version.to_string(),
            components,
            created: self.current_timestamp(),
            hash: "sha256:sbomhash123...".to_string(),
        };

        Ok(sbom)
    }

    /// Store an SBOM
    pub fn store_sbom(&mut self, sbom: Sbom) -> Result<(), SupplyChainError> {
        self.sboms.insert(sbom.id.clone(), sbom);
        Ok(())
    }

    /// Get an SBOM by ID
    pub fn get_sbom(&self, id: &str) -> Option<&Sbom> {
        self.sboms.get(id)
    }

    /// Create a signature for an artifact
    pub fn create_signature(&self, artifact_hash: &str) -> Result<Signature, SupplyChainError> {
        // In a real implementation, this would use actual cryptographic signing
        // For this example, we'll create a placeholder signature

        let signature = Signature {
            algorithm: "RSA-SHA256".to_string(),
            public_key: "public-key-placeholder".to_string(),
            signature: format!("signature-for-{}", artifact_hash),
            timestamp: self.current_timestamp(),
        };

        Ok(signature)
    }

    /// Store a signature
    pub fn store_signature(
        &mut self,
        artifact_uri: &str,
        signature: Signature,
    ) -> Result<(), SupplyChainError> {
        self.signatures.insert(artifact_uri.to_string(), signature);
        Ok(())
    }

    /// Verify a signature
    pub fn verify_signature(
        &self,
        artifact_hash: &str,
        signature: &Signature,
    ) -> Result<bool, SupplyChainError> {
        // In a real implementation, this would perform actual cryptographic verification
        // For this example, we'll just check if the signature matches our placeholder format
        let expected_signature = format!("signature-for-{}", artifact_hash);
        Ok(signature.signature == expected_signature)
    }

    /// Create provenance information for a build
    pub fn create_provenance(
        &self,
        build_id: &str,
        source: SourceInfo,
        build_config: BuildConfig,
        artifacts: Vec<Artifact>,
    ) -> Result<Provenance, SupplyChainError> {
        let provenance = Provenance {
            id: format!("prov-{}", build_id),
            build_id: build_id.to_string(),
            source,
            build_config,
            builder: BuilderInfo {
                id: "default-builder".to_string(),
                version: "1.0.0".to_string(),
                platform: "linux-amd64".to_string(),
            },
            artifacts,
            created: self.current_timestamp(),
        };

        Ok(provenance)
    }

    /// Store provenance information
    pub fn store_provenance(&mut self, provenance: Provenance) -> Result<(), SupplyChainError> {
        self.provenance.insert(provenance.id.clone(), provenance);
        Ok(())
    }

    /// Get provenance by ID
    pub fn get_provenance(&self, id: &str) -> Option<&Provenance> {
        self.provenance.get(id)
    }

    /// Create an artifact with integrity information
    pub fn create_artifact(
        &self,
        name: &str,
        uri: &str,
        hash: &str,
        size: u64,
        signature: Option<Signature>,
        sbom: Option<Sbom>,
    ) -> Result<Artifact, SupplyChainError> {
        // An artifact is considered signed if it has either a regular signature or a cosign signature
        let is_signed = signature.is_some() || self.cosign_signatures.contains_key(uri);
        let artifact = Artifact {
            name: name.to_string(),
            uri: uri.to_string(),
            hash: hash.to_string(),
            size,
            signature,
            sbom,
            is_signed,
            created: self.current_timestamp(),
        };

        Ok(artifact)
    }

    /// Sign an artifact with Sigstore/cosign
    pub fn sign_artifact_with_cosign(
        &mut self,
        artifact_uri: &str,
        payload: &str,
    ) -> Result<CosignSignature, SupplyChainError> {
        // In a real implementation, this would use the actual cosign tool
        // For this example, we'll create a placeholder signature

        let signature = CosignSignature {
            payload: payload.to_string(),
            signature: format!("cosign-signature-for-{}", artifact_uri),
            certificate: "cosign-certificate-placeholder".to_string(),
            timestamp: self.current_timestamp(),
        };

        self.cosign_signatures
            .insert(artifact_uri.to_string(), signature.clone());
        Ok(signature)
    }

    /// Verify Sigstore/cosign signature
    pub fn verify_cosign_signature(
        &self,
        artifact_uri: &str,
        signature: &CosignSignature,
    ) -> Result<bool, SupplyChainError> {
        // In a real implementation, this would perform actual cosign verification
        // For this example, we'll just check if the signature matches our placeholder format
        let expected_signature = format!("cosign-signature-for-{}", artifact_uri);
        Ok(signature.signature == expected_signature)
    }

    /// Attach SBOM to an artifact
    pub fn attach_sbom_to_artifact(
        &mut self,
        artifact: &mut Artifact,
        sbom: Sbom,
    ) -> Result<(), SupplyChainError> {
        artifact.sbom = Some(sbom);
        Ok(())
    }

    /// Verify artifact integrity (signature and SBOM)
    pub fn verify_artifact_integrity(
        &self,
        artifact: &Artifact,
    ) -> Result<bool, SupplyChainError> {
        // Update statistics
        self.integrity_stats
            .total_artifacts
            .fetch_add(1, Ordering::Relaxed);

        // Check if artifact is signed (either regular signature or cosign signature)
        if !artifact.is_signed {
            self.integrity_stats
                .unsigned_blocked
                .fetch_add(1, Ordering::Relaxed);
            return Ok(false);
        }

        // Verify signature if present
        if let Some(signature) = &artifact.signature {
            if self.verify_signature(&artifact.hash, signature)? {
                self.integrity_stats
                    .signed_verified
                    .fetch_add(1, Ordering::Relaxed);
            } else {
                self.integrity_stats
                    .signature_failures
                    .fetch_add(1, Ordering::Relaxed);
                return Ok(false);
            }
        }

        // Verify cosign signature if present
        if let Some(cosign_sig) = self.cosign_signatures.get(&artifact.uri) {
            if self.verify_cosign_signature(&artifact.uri, cosign_sig)? {
                self.integrity_stats
                    .signed_verified
                    .fetch_add(1, Ordering::Relaxed);
            } else {
                self.integrity_stats
                    .signature_failures
                    .fetch_add(1, Ordering::Relaxed);
                return Ok(false);
            }
        }

        Ok(true)
    }

    /// Get artifact integrity statistics
    pub fn get_integrity_stats(&self) -> (u64, u64, u64, u64) {
        let total = self.integrity_stats.total_artifacts.load(Ordering::Relaxed);
        let unsigned = self.integrity_stats.unsigned_blocked.load(Ordering::Relaxed);
        let verified = self.integrity_stats.signed_verified.load(Ordering::Relaxed);
        let failures = self.integrity_stats.signature_failures.load(Ordering::Relaxed);
        (total, unsigned, verified, failures)
    }

    /// Scan dependencies for vulnerabilities
    pub fn scan_dependencies(&self, _sbom: &Sbom) -> Result<Vec<Vulnerability>, SupplyChainError> {
        // In a real implementation, this would query vulnerability databases
        // For this example, we'll return an empty list
        Ok(vec![])
    }

    /// Validate that all dependencies are pinned
    pub fn validate_dependency_pinning(&self, sbom: &Sbom) -> Result<bool, SupplyChainError> {
        // In a real implementation, this would check that all dependencies
        // have specific version pins rather than version ranges
        // For this example, we'll check the is_pinned flag on components
        for component in &sbom.components {
            if !component.is_pinned {
                return Ok(false);
            }
        }
        Ok(true)
    }

    /// Verify component checksums
    pub fn verify_component_checksums(&self, sbom: &Sbom) -> Result<bool, SupplyChainError> {
        // In a real implementation, this would verify actual checksums
        // For this example, we'll check the checksum_verified flag on components
        for component in &sbom.components {
            if !component.checksum_verified {
                self.trust_stats
                    .checksum_failures
                    .fetch_add(1, Ordering::Relaxed);
                return Ok(false);
            }
        }
        Ok(true)
    }

    /// Check if dependencies are approved
    pub fn check_dependency_approval(&self, sbom: &Sbom) -> Result<bool, SupplyChainError> {
        self.trust_stats
            .total_dependencies
            .fetch_add(sbom.components.len() as u64, Ordering::Relaxed);
            
        for component in &sbom.components {
            if !component.is_approved {
                self.trust_stats
                    .unapproved_blocked
                    .fetch_add(1, Ordering::Relaxed);
                return Ok(false);
            }
        }
        Ok(true)
    }

    /// Detect typosquat packages
    pub fn detect_typosquat_packages(&self, sbom: &Sbom) -> Result<Vec<String>, SupplyChainError> {
        let mut detected = Vec::new();
        
        for component in &sbom.components {
            if self.typosquat_packages.contains_key(&component.name) {
                self.trust_stats
                    .typosquat_detected
                    .fetch_add(1, Ordering::Relaxed);
                detected.push(component.name.clone());
            }
        }
        
        Ok(detected)
    }

    /// Validate dependency trust (SCA / Pin / Verify)
    pub fn validate_dependency_trust(&self, sbom: &Sbom) -> Result<bool, SupplyChainError> {
        // Check if all dependencies are pinned
        if !self.validate_dependency_pinning(sbom)? {
            return Err(SupplyChainError::DependencyTrustValidationFailed(
                "Dependencies are not properly pinned".to_string()
            ));
        }
        
        // Verify component checksums
        if !self.verify_component_checksums(sbom)? {
            return Err(SupplyChainError::DependencyTrustValidationFailed(
                "Component checksum verification failed".to_string()
            ));
        }
        
        // Check if dependencies are approved
        if !self.check_dependency_approval(sbom)? {
            return Err(SupplyChainError::DependencyTrustValidationFailed(
                "Unapproved dependencies detected".to_string()
            ));
        }
        
        // Detect typosquat packages
        let typosquat_packages = self.detect_typosquat_packages(sbom)?;
        if !typosquat_packages.is_empty() {
            return Err(SupplyChainError::DependencyTrustValidationFailed(
                format!("Typosquat packages detected: {:?}", typosquat_packages)
            ));
        }
        
        Ok(true)
    }

    /// Get dependency trust statistics
    pub fn get_trust_stats(&self) -> (u64, u64, u64, u64) {
        let total = self.trust_stats.total_dependencies.load(Ordering::Relaxed);
        let unapproved = self.trust_stats.unapproved_blocked.load(Ordering::Relaxed);
        let typosquat = self.trust_stats.typosquat_detected.load(Ordering::Relaxed);
        let checksum = self.trust_stats.checksum_failures.load(Ordering::Relaxed);
        (total, unapproved, typosquat, checksum)
    }

    /// Add an approved dependency
    pub fn add_approved_dependency(&mut self, name: &str, version_regex: &str) {
        self.approved_dependencies.insert(name.to_string(), version_regex.to_string());
    }

    /// Remove an approved dependency
    pub fn remove_approved_dependency(&mut self, name: &str) {
        self.approved_dependencies.remove(name);
    }

    /// Add a typosquat package to detection list
    pub fn add_typosquat_package(&mut self, suspicious_name: &str, legitimate_name: &str) {
        self.typosquat_packages.insert(suspicious_name.to_string(), legitimate_name.to_string());
    }

    /// Get current timestamp
    fn current_timestamp(&self) -> u64 {
        use std::time::{SystemTime, UNIX_EPOCH};
        SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .map(|d| d.as_secs())
            .unwrap_or(0)
    }

    /// Create a build with CI/CD policy enforcement
    pub fn create_build(
        &mut self,
        build_number: &str,
        source: SourceInfo,
        config: BuildConfig,
        artifacts: Vec<Artifact>,
    ) -> Result<Build, SupplyChainError> {
        // Update statistics
        self.cicd_stats
            .total_builds
            .fetch_add(1, Ordering::Relaxed);
            
        let build_id = format!("build-{}", build_number);
        
        // Get all policy rules
        let policy_rules: Vec<PolicyRule> = self.policy_rules.values().cloned().collect();
        
        // Create initial build with all policies marked as not evaluated
        let mut policy_results = HashMap::new();
        for rule in &policy_rules {
            policy_results.insert(rule.id.clone(), false);
        }
        
        let build = Build {
            id: build_id.clone(),
            build_number: build_number.to_string(),
            source,
            config,
            artifacts,
            policy_rules,
            policy_results,
            created: self.current_timestamp(),
            passed_policies: false,
        };

        Ok(build)
    }

    /// Store a build
    pub fn store_build(&mut self, build: Build) -> Result<(), SupplyChainError> {
        self.builds.insert(build.id.clone(), build);
        Ok(())
    }

    /// Get a build by ID
    pub fn get_build(&self, id: &str) -> Option<&Build> {
        self.builds.get(id)
    }

    /// Perform security scan on a build
    pub fn perform_security_scan(
        &mut self,
        build_id: &str,
        scan_type: &str,
    ) -> Result<SecurityScanResult, SupplyChainError> {
        // Update statistics
        self.cicd_stats
            .security_scans
            .fetch_add(1, Ordering::Relaxed);
            
        let scan_id = format!("scan-{}-{}", build_id, self.current_timestamp());
        
        // In a real implementation, this would perform actual security scanning
        // For this example, we'll create a placeholder result
        let vulnerabilities = vec![];
        let licenses = vec!["MIT".to_string(), "Apache-2.0".to_string()];
        let passed = true; // For this example, we'll assume the scan passes
        
        let scan_result = SecurityScanResult {
            id: scan_id.clone(),
            build_id: build_id.to_string(),
            scan_type: scan_type.to_string(),
            vulnerabilities,
            licenses,
            completed: self.current_timestamp(),
            passed,
        };
        
        self.security_scans.insert(scan_id, scan_result.clone());
        Ok(scan_result)
    }

    /// Record test results for a build
    pub fn record_test_results(
        &mut self,
        build_id: &str,
        test_type: &str,
        tests_executed: u64,
        tests_passed: u64,
        tests_failed: u64,
        coverage: f32,
    ) -> Result<TestResult, SupplyChainError> {
        // Update statistics
        self.cicd_stats
            .tests_executed
            .fetch_add(1, Ordering::Relaxed);
            
        let test_id = format!("test-{}-{}", build_id, self.current_timestamp());
        
        let passed = tests_failed == 0;
        
        let test_result = TestResult {
            id: test_id.clone(),
            build_id: build_id.to_string(),
            test_type: test_type.to_string(),
            tests_executed,
            tests_passed,
            tests_failed,
            coverage,
            completed: self.current_timestamp(),
            passed,
        };
        
        self.test_results.insert(test_id, test_result.clone());
        Ok(test_result)
    }

    /// Evaluate policy rules for a build
    pub fn evaluate_policies(&mut self, build_id: &str) -> Result<bool, SupplyChainError> {
        // Clone the necessary data to avoid borrowing issues
        let (policy_rules, enabled_rules): (Vec<PolicyRule>, Vec<bool>) = {
            let build = self.builds.get(build_id).ok_or_else(|| {
                SupplyChainError::ConfigurationError("Build not found".to_string())
            })?;
            let rules = build.policy_rules.clone();
            let enabled: Vec<bool> = rules.iter().map(|r| r.enabled).collect();
            (rules, enabled)
        };
        
        let mut policy_results = HashMap::new();
        let mut all_passed = true;
        
        // Evaluate each policy rule
        for (i, rule) in policy_rules.iter().enumerate() {
            if !enabled_rules[i] {
                // Skip disabled rules
                policy_results.insert(rule.id.clone(), true);
                continue;
            }
            
            let passed = match rule.category.as_str() {
                "security" => self.evaluate_security_policy(build_id, rule)?,
                "license" => self.evaluate_license_policy(build_id, rule)?,
                "quality" => self.evaluate_quality_policy(build_id, rule)?,
                "compliance" => self.evaluate_compliance_policy(build_id, rule)?,
                _ => {
                    // Unknown category, fail the policy
                    false
                }
            };
            
            policy_results.insert(rule.id.clone(), passed);
            
            if !passed && rule.severity == "critical" {
                // Critical policy failure blocks the build
                all_passed = false;
            }
        }
        
        // Update the build with results
        let build = self.builds.get_mut(build_id).ok_or_else(|| {
            SupplyChainError::ConfigurationError("Build not found".to_string())
        })?;
        build.policy_results = policy_results;
        build.passed_policies = all_passed;
        
        // Update statistics if build is blocked
        if !all_passed {
            self.cicd_stats
                .builds_blocked
                .fetch_add(1, Ordering::Relaxed);
        }
        
        Ok(all_passed)
    }

    /// Evaluate security policy rules
    fn evaluate_security_policy(&self, build_id: &str, rule: &PolicyRule) -> Result<bool, SupplyChainError> {
        match rule.id.as_str() {
            "security-scan-required" => {
                // Check if security scans were performed for this build
                for scan in self.security_scans.values() {
                    if scan.build_id == build_id {
                        return Ok(scan.passed);
                    }
                }
                // No security scan found
                Ok(false)
            }
            "no-critical-vulns" => {
                // Check if any critical vulnerabilities were found
                for scan in self.security_scans.values() {
                    if scan.build_id == build_id {
                        for vuln in &scan.vulnerabilities {
                            if vuln.severity >= 9.0 {
                                return Ok(false); // Critical vulnerability found
                            }
                        }
                    }
                }
                Ok(true) // No critical vulnerabilities found
            }
            _ => Ok(true) // Unknown security rule, pass by default
        }
    }

    /// Evaluate license policy rules
    fn evaluate_license_policy(&self, build_id: &str, rule: &PolicyRule) -> Result<bool, SupplyChainError> {
        match rule.id.as_str() {
            "approved-licenses-only" => {
                // Check if all licenses in security scans are approved
                for scan in self.security_scans.values() {
                    if scan.build_id == build_id {
                        for license in &scan.licenses {
                            // In a real implementation, we would check against approved licenses
                            // For this example, we'll assume MIT and Apache-2.0 are approved
                            if license != "MIT" && license != "Apache-2.0" {
                                return Ok(false); // Unapproved license found
                            }
                        }
                    }
                }
                Ok(true) // All licenses are approved
            }
            _ => Ok(true) // Unknown license rule, pass by default
        }
    }

    /// Evaluate quality policy rules
    fn evaluate_quality_policy(&self, build_id: &str, rule: &PolicyRule) -> Result<bool, SupplyChainError> {
        match rule.id.as_str() {
            "minimum-test-coverage" => {
                // Check if test coverage meets minimum requirements (e.g., 80%)
                for test in self.test_results.values() {
                    if test.build_id == build_id {
                        if test.coverage < 80.0 {
                            return Ok(false); // Coverage below minimum
                        }
                    }
                }
                Ok(true) // Coverage meets minimum requirements
            }
            "all-tests-must-pass" => {
                // Check if all tests passed
                for test in self.test_results.values() {
                    if test.build_id == build_id {
                        if !test.passed {
                            return Ok(false); // Some tests failed
                        }
                    }
                }
                Ok(true) // All tests passed
            }
            _ => Ok(true) // Unknown quality rule, pass by default
        }
    }

    /// Evaluate compliance policy rules
    fn evaluate_compliance_policy(&self, build_id: &str, rule: &PolicyRule) -> Result<bool, SupplyChainError> {
        match rule.id.as_str() {
            "dependency-trust-check" => {
                // Check if all artifacts in the build pass dependency trust validation
                let build = self.builds.get(build_id).ok_or_else(|| {
                    SupplyChainError::ConfigurationError("Build not found".to_string())
                })?;
                
                for artifact in &build.artifacts {
                    if let Some(sbom) = &artifact.sbom {
                        if !self.validate_dependency_trust(sbom)? {
                            return Ok(false); // Dependency trust validation failed
                        }
                    }
                }
                Ok(true) // All artifacts pass dependency trust validation
            }
            _ => Ok(true) // Unknown compliance rule, pass by default
        }
    }

    /// Get CI/CD gatekeeping statistics
    pub fn get_cicd_stats(&self) -> (u64, u64, u64, u64) {
        let total = self.cicd_stats.total_builds.load(Ordering::Relaxed);
        let blocked = self.cicd_stats.builds_blocked.load(Ordering::Relaxed);
        let scans = self.cicd_stats.security_scans.load(Ordering::Relaxed);
        let tests = self.cicd_stats.tests_executed.load(Ordering::Relaxed);
        (total, blocked, scans, tests)
    }

    /// Add a policy rule
    pub fn add_policy_rule(&mut self, rule: PolicyRule) {
        self.policy_rules.insert(rule.id.clone(), rule);
    }

    /// Remove a policy rule
    pub fn remove_policy_rule(&mut self, rule_id: &str) {
        self.policy_rules.remove(rule_id);
    }

    /// Enable a policy rule
    pub fn enable_policy_rule(&mut self, rule_id: &str) -> Result<(), SupplyChainError> {
        let rule = self.policy_rules.get_mut(rule_id).ok_or_else(|| {
            SupplyChainError::ConfigurationError("Policy rule not found".to_string())
        })?;
        rule.enabled = true;
        Ok(())
    }

    /// Disable a policy rule
    pub fn disable_policy_rule(&mut self, rule_id: &str) -> Result<(), SupplyChainError> {
        let rule = self.policy_rules.get_mut(rule_id).ok_or_else(|| {
            SupplyChainError::ConfigurationError("Policy rule not found".to_string())
        })?;
        rule.enabled = false;
        Ok(())
    }
}

impl Default for SupplyChainManager {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_supply_chain_manager_creation() {
        let manager = SupplyChainManager::new();
        assert_eq!(manager.sboms.len(), 0);
        assert_eq!(manager.signatures.len(), 0);
        assert_eq!(manager.provenance.len(), 0);
        assert_eq!(manager.cosign_signatures.len(), 0);
    }

    #[test]
    fn test_sbom_generation() {
        let manager = SupplyChainManager::new();
        let sbom = manager.generate_sbom("test-component", "1.0.0").unwrap();
        assert_eq!(sbom.name, "test-component");
        assert_eq!(sbom.version, "1.0.0");
        assert_eq!(sbom.components.len(), 2);
    }

    #[test]
    fn test_sbom_storage_and_retrieval() {
        let mut manager = SupplyChainManager::new();
        let sbom = manager.generate_sbom("test-component", "1.0.0").unwrap();
        let sbom_id = sbom.id.clone();

        assert!(manager.store_sbom(sbom).is_ok());
        assert_eq!(manager.sboms.len(), 1);
        assert!(manager.get_sbom(&sbom_id).is_some());
    }

    #[test]
    fn test_signature_creation_and_verification() {
        let manager = SupplyChainManager::new();
        let artifact_hash = "sha256:test123";

        let signature = manager.create_signature(artifact_hash).unwrap();
        assert!(manager.verify_signature(artifact_hash, &signature).unwrap());

        // Test with wrong hash
        assert!(!manager
            .verify_signature("sha256:wrong", &signature)
            .unwrap());
    }

    #[test]
    fn test_signature_storage() {
        let mut manager = SupplyChainManager::new();
        let artifact_uri = "artifact://test";
        let signature = manager.create_signature("sha256:test123").unwrap();

        assert!(manager.store_signature(artifact_uri, signature).is_ok());
        assert_eq!(manager.signatures.len(), 1);
    }

    #[test]
    fn test_provenance_creation_storage_and_retrieval() {
        let mut manager = SupplyChainManager::new();

        let source = SourceInfo {
            repo_url: "https://github.com/example/repo".to_string(),
            commit_hash: "abc123".to_string(),
            branch: "main".to_string(),
            tag: Some("v1.0.0".to_string()),
        };

        let build_config = BuildConfig {
            build_script: "build.sh".to_string(),
            environment: HashMap::new(),
            tools: HashMap::new(),
        };

        let artifacts = vec![Artifact {
            name: "test-artifact".to_string(),
            uri: "artifact://test".to_string(),
            hash: "sha256:test123".to_string(),
            size: 1024,
            signature: None,
            sbom: None,
            is_signed: false,
            created: 0,
        }];

        let provenance = manager
            .create_provenance("build-123", source, build_config, artifacts)
            .unwrap();
        let provenance_id = provenance.id.clone();

        assert!(manager.store_provenance(provenance).is_ok());
        assert_eq!(manager.provenance.len(), 1);
        assert!(manager.get_provenance(&provenance_id).is_some());
    }

    #[test]
    fn test_dependency_scanning() {
        let manager = SupplyChainManager::new();
        let sbom = manager.generate_sbom("test-component", "1.0.0").unwrap();
        let vulnerabilities = manager.scan_dependencies(&sbom).unwrap();
        assert_eq!(vulnerabilities.len(), 0);
    }

    #[test]
    fn test_dependency_pinning_validation() {
        let manager = SupplyChainManager::new();
        let sbom = manager.generate_sbom("test-component", "1.0.0").unwrap();
        let is_pinned = manager.validate_dependency_pinning(&sbom).unwrap();
        assert!(is_pinned);
    }

    #[test]
    fn test_artifact_creation_with_integrity() {
        let manager = SupplyChainManager::new();
        let signature = manager.create_signature("sha256:test123").unwrap();
        let sbom = manager.generate_sbom("test-component", "1.0.0").unwrap();

        let artifact = manager
            .create_artifact(
                "test-artifact",
                "artifact://test",
                "sha256:test123",
                1024,
                Some(signature),
                Some(sbom),
            )
            .unwrap();

        assert_eq!(artifact.name, "test-artifact");
        assert_eq!(artifact.uri, "artifact://test");
        assert_eq!(artifact.hash, "sha256:test123");
        assert_eq!(artifact.size, 1024);
        assert!(artifact.signature.is_some());
        assert!(artifact.sbom.is_some());
        assert!(artifact.is_signed);
    }

    #[test]
    fn test_cosign_signing_and_verification() {
        let mut manager = SupplyChainManager::new();
        let artifact_uri = "artifact://test-container";
        let payload = "container-image-payload";

        let signature = manager
            .sign_artifact_with_cosign(artifact_uri, payload)
            .unwrap();
        assert_eq!(signature.payload, payload);
        assert_eq!(signature.signature, "cosign-signature-for-artifact://test-container");

        assert!(manager.cosign_signatures.len() == 1);
        assert!(manager
            .verify_cosign_signature(artifact_uri, &signature)
            .unwrap());
    }

    #[test]
    fn test_artifact_integrity_verification() {
        let manager = SupplyChainManager::new();

        // Create a signed artifact
        let signature = manager.create_signature("sha256:test123").unwrap();
        let sbom = manager.generate_sbom("test-component", "1.0.0").unwrap();

        let artifact = manager
            .create_artifact(
                "test-artifact",
                "artifact://test",
                "sha256:test123",
                1024,
                Some(signature),
                Some(sbom),
            )
            .unwrap();

        // Verify integrity of signed artifact
        assert!(manager.verify_artifact_integrity(&artifact).unwrap());

        // Create an unsigned artifact
        let unsigned_artifact = manager
            .create_artifact("unsigned-artifact", "artifact://unsigned", "sha256:unsigned", 512, None, None)
            .unwrap();

        // Verify integrity of unsigned artifact (should fail)
        assert!(!manager.verify_artifact_integrity(&unsigned_artifact).unwrap());

        // Check statistics
        let (total, unsigned, verified, failures) = manager.get_integrity_stats();
        assert_eq!(total, 2); // Two artifacts checked
        assert_eq!(unsigned, 1); // One unsigned artifact blocked
        assert_eq!(verified, 1); // One signed artifact verified
        assert_eq!(failures, 0); // No signature failures
    }

    #[test]
    fn test_sbom_attachment_to_artifact() {
        let mut manager = SupplyChainManager::new();
        let mut artifact = manager
            .create_artifact("test-artifact", "artifact://test", "sha256:test123", 1024, None, None)
            .unwrap();

        let sbom = manager.generate_sbom("attached-component", "2.0.0").unwrap();
        assert!(manager.attach_sbom_to_artifact(&mut artifact, sbom).is_ok());
        assert!(artifact.sbom.is_some());
        assert_eq!(artifact.sbom.as_ref().unwrap().name, "attached-component");
    }

    #[test]
    fn test_dependency_trust_validation() {
        let manager = SupplyChainManager::new();
        let sbom = manager.generate_sbom("test-component", "1.0.0").unwrap();
        
        // Test that the generated SBOM passes trust validation
        let is_trusted = manager.validate_dependency_trust(&sbom).unwrap();
        assert!(is_trusted);
    }

    #[test]
    fn test_dependency_trust_with_unapproved_dependency() {
        let mut manager = SupplyChainManager::new();
        
        // Create an SBOM with an unapproved dependency
        let unapproved_component = Component {
            id: "unapproved-component".to_string(),
            name: "malicious-dep".to_string(),
            version: "1.0.0".to_string(),
            purl: "pkg:cargo/malicious-dep@1.0.0".to_string(),
            licenses: vec!["MIT".to_string()],
            hash: "sha256:malicioushash".to_string(),
            is_direct: true,
            vulnerabilities: vec![],
            is_pinned: true,
            checksum_verified: true,
            is_approved: false, // Not approved
        };

        let sbom = Sbom {
            id: "test-sbom-unapproved".to_string(),
            name: "test-app".to_string(),
            version: "1.0.0".to_string(),
            components: vec![unapproved_component],
            created: 1234567890,
            hash: "sha256:sbomhash".to_string(),
        };

        // Validation should fail due to unapproved dependency
        let result = manager.validate_dependency_trust(&sbom);
        assert!(result.is_err());
        
        // Check that the error is the expected type
        match result {
            Err(SupplyChainError::DependencyTrustValidationFailed(msg)) => {
                assert!(msg.contains("Unapproved dependencies detected"));
            }
            _ => panic!("Expected DependencyTrustValidationFailed error"),
        }
        
        // Check statistics
        let (total, unapproved, typosquat, checksum) = manager.get_trust_stats();
        assert_eq!(total, 1); // One dependency checked
        assert_eq!(unapproved, 1); // One unapproved dependency blocked
        assert_eq!(typosquat, 0);
        assert_eq!(checksum, 0);
    }

    #[test]
    fn test_dependency_trust_with_typosquat_package() {
        let mut manager = SupplyChainManager::new();
        
        // Add a typosquat package to detection list
        manager.add_typosquat_package("serede", "serde");
        
        // Create an SBOM with a typosquat package
        let typosquat_component = Component {
            id: "typosquat-component".to_string(),
            name: "serede".to_string(), // Typosquat for "serde"
            version: "1.0.0".to_string(),
            purl: "pkg:cargo/serede@1.0.0".to_string(),
            licenses: vec!["MIT".to_string()],
            hash: "sha256:typosquathash".to_string(),
            is_direct: true,
            vulnerabilities: vec![],
            is_pinned: true,
            checksum_verified: true,
            is_approved: true,
        };

        let sbom = Sbom {
            id: "test-sbom-typosquat".to_string(),
            name: "test-app".to_string(),
            version: "1.0.0".to_string(),
            components: vec![typosquat_component],
            created: 1234567890,
            hash: "sha256:sbomhash".to_string(),
        };

        // Validation should fail due to typosquat package
        let result = manager.validate_dependency_trust(&sbom);
        assert!(result.is_err());
        
        // Check that the error is the expected type
        match result {
            Err(SupplyChainError::DependencyTrustValidationFailed(msg)) => {
                assert!(msg.contains("Typosquat packages detected"));
                assert!(msg.contains("serede"));
            }
            _ => panic!("Expected DependencyTrustValidationFailed error"),
        }
        
        // Check statistics
        let (total, unapproved, typosquat, checksum) = manager.get_trust_stats();
        assert_eq!(total, 1); // One dependency checked
        assert_eq!(unapproved, 0);
        assert_eq!(typosquat, 1); // One typosquat package detected
        assert_eq!(checksum, 0);
    }

    #[test]
    fn test_dependency_trust_with_unpinned_dependency() {
        let manager = SupplyChainManager::new();
        
        // Create an SBOM with an unpinned dependency
        let unpinned_component = Component {
            id: "unpinned-component".to_string(),
            name: "unpinned-dep".to_string(),
            version: "1.0.0".to_string(),
            purl: "pkg:cargo/unpinned-dep@1.0.0".to_string(),
            licenses: vec!["MIT".to_string()],
            hash: "sha256:unpinnedhash".to_string(),
            is_direct: true,
            vulnerabilities: vec![],
            is_pinned: false, // Not pinned
            checksum_verified: true,
            is_approved: true,
        };

        let sbom = Sbom {
            id: "test-sbom-unpinned".to_string(),
            name: "test-app".to_string(),
            version: "1.0.0".to_string(),
            components: vec![unpinned_component],
            created: 1234567890,
            hash: "sha256:sbomhash".to_string(),
        };

        // Validation should fail due to unpinned dependency
        let result = manager.validate_dependency_trust(&sbom);
        assert!(result.is_err());
        
        // Check that the error is the expected type
        match result {
            Err(SupplyChainError::DependencyTrustValidationFailed(msg)) => {
                assert!(msg.contains("Dependencies are not properly pinned"));
            }
            _ => panic!("Expected DependencyTrustValidationFailed error"),
        }
    }

    #[test]
    fn test_dependency_trust_with_checksum_failure() {
        let manager = SupplyChainManager::new();
        
        // Create an SBOM with a component that failed checksum verification
        let checksum_component = Component {
            id: "checksum-component".to_string(),
            name: "checksum-dep".to_string(),
            version: "1.0.0".to_string(),
            purl: "pkg:cargo/checksum-dep@1.0.0".to_string(),
            licenses: vec!["MIT".to_string()],
            hash: "sha256:checksumhash".to_string(),
            is_direct: true,
            vulnerabilities: vec![],
            is_pinned: true,
            checksum_verified: false, // Checksum verification failed
            is_approved: true,
        };

        let sbom = Sbom {
            id: "test-sbom-checksum".to_string(),
            name: "test-app".to_string(),
            version: "1.0.0".to_string(),
            components: vec![checksum_component],
            created: 1234567890,
            hash: "sha256:sbomhash".to_string(),
        };

        // Validation should fail due to checksum verification failure
        let result = manager.validate_dependency_trust(&sbom);
        assert!(result.is_err());
        
        // Check that the error is the expected type
        match result {
            Err(SupplyChainError::DependencyTrustValidationFailed(msg)) => {
                assert!(msg.contains("Component checksum verification failed"));
            }
            _ => panic!("Expected DependencyTrustValidationFailed error"),
        }
    }

    #[test]
    fn test_approved_dependency_management() {
        let mut manager = SupplyChainManager::new();
        
        // Add an approved dependency
        manager.add_approved_dependency("test-dep", r"^1\.[0-9]+\.[0-9]+$");
        assert!(manager.approved_dependencies.contains_key("test-dep"));
        
        // Remove an approved dependency
        manager.remove_approved_dependency("test-dep");
        assert!(!manager.approved_dependencies.contains_key("test-dep"));
    }

    #[test]
    fn test_typosquat_detection_management() {
        let mut manager = SupplyChainManager::new();
        
        // Add a typosquat package to detection list
        manager.add_typosquat_package("suspicious-name", "legitimate-name");
        assert!(manager.typosquat_packages.contains_key("suspicious-name"));
    }

    #[test]
    fn test_get_trust_stats() {
        let manager = SupplyChainManager::new();
        let (total, unapproved, typosquat, checksum) = manager.get_trust_stats();
        assert_eq!(total, 0);
        assert_eq!(unapproved, 0);
        assert_eq!(typosquat, 0);
        assert_eq!(checksum, 0);
    }

    #[test]
    fn test_cicd_gatekeeping_initialization() {
        let manager = SupplyChainManager::new();
        assert_eq!(manager.builds.len(), 0);
        assert_eq!(manager.security_scans.len(), 0);
        assert_eq!(manager.test_results.len(), 0);
        assert!(!manager.policy_rules.is_empty());
        
        // Check that default policies are loaded
        assert!(manager.policy_rules.contains_key("security-scan-required"));
        assert!(manager.policy_rules.contains_key("no-critical-vulns"));
        assert!(manager.policy_rules.contains_key("approved-licenses-only"));
        assert!(manager.policy_rules.contains_key("minimum-test-coverage"));
        assert!(manager.policy_rules.contains_key("all-tests-must-pass"));
        assert!(manager.policy_rules.contains_key("dependency-trust-check"));
    }

    #[test]
    fn test_build_creation_and_storage() {
        let mut manager = SupplyChainManager::new();
        
        let source = SourceInfo {
            repo_url: "https://github.com/example/test-app".to_string(),
            commit_hash: "a1b2c3d4e5f".to_string(),
            branch: "main".to_string(),
            tag: Some("v1.0.0".to_string()),
        };

        let build_config = BuildConfig {
            build_script: "build.sh".to_string(),
            environment: std::collections::HashMap::new(),
            tools: std::collections::HashMap::new(),
        };

        let artifacts = vec![Artifact {
            name: "test-app-binary".to_string(),
            uri: "artifact://test-app-v1.0.0".to_string(),
            hash: "sha256:test123".to_string(),
            size: 2048,
            signature: None,
            sbom: None,
            is_signed: false,
            created: 0,
        }];
        
        let build = manager.create_build("123", source, build_config, artifacts).unwrap();
        assert_eq!(build.build_number, "123");
        assert_eq!(build.artifacts.len(), 1);
        assert!(!build.passed_policies); // Should be false initially
        
        // Store the build
        assert!(manager.store_build(build.clone()).is_ok());
        assert_eq!(manager.builds.len(), 1);
        
        // Retrieve the build
        let retrieved_build = manager.get_build(&build.id).unwrap();
        assert_eq!(retrieved_build.build_number, "123");
    }

    #[test]
    fn test_security_scan() {
        let mut manager = SupplyChainManager::new();
        let scan_result = manager.perform_security_scan("build-123", "sast").unwrap();
        assert_eq!(scan_result.build_id, "build-123");
        assert_eq!(scan_result.scan_type, "sast");
        assert!(scan_result.passed);
        assert_eq!(manager.security_scans.len(), 1);
    }

    #[test]
    fn test_test_results_recording() {
        let mut manager = SupplyChainManager::new();
        let test_result = manager.record_test_results("build-123", "unit", 100, 95, 5, 95.0).unwrap();
        assert_eq!(test_result.build_id, "build-123");
        assert_eq!(test_result.test_type, "unit");
        assert_eq!(test_result.tests_executed, 100);
        assert_eq!(test_result.tests_passed, 95);
        assert_eq!(test_result.tests_failed, 5);
        assert_eq!(test_result.coverage, 95.0);
        assert!(!test_result.passed); // Because some tests failed
        assert_eq!(manager.test_results.len(), 1);
    }

    #[test]
    fn test_policy_rule_management() {
        let mut manager = SupplyChainManager::new();
        
        // Add a new policy rule
        let new_rule = PolicyRule {
            id: "custom-rule".to_string(),
            name: "Custom Rule".to_string(),
            description: "A custom policy rule".to_string(),
            enabled: true,
            severity: "medium".to_string(),
            category: "security".to_string(),
        };
        
        manager.add_policy_rule(new_rule);
        assert!(manager.policy_rules.contains_key("custom-rule"));
        
        // Disable the rule
        assert!(manager.disable_policy_rule("custom-rule").is_ok());
        assert!(!manager.policy_rules.get("custom-rule").unwrap().enabled);
        
        // Enable the rule
        assert!(manager.enable_policy_rule("custom-rule").is_ok());
        assert!(manager.policy_rules.get("custom-rule").unwrap().enabled);
        
        // Remove the rule
        manager.remove_policy_rule("custom-rule");
        assert!(!manager.policy_rules.contains_key("custom-rule"));
    }

    #[test]
    fn test_policy_evaluation() {
        let mut manager = SupplyChainManager::new();
        
        let source = SourceInfo {
            repo_url: "https://github.com/example/test-app".to_string(),
            commit_hash: "a1b2c3d4e5f".to_string(),
            branch: "main".to_string(),
            tag: Some("v1.0.0".to_string()),
        };

        let build_config = BuildConfig {
            build_script: "build.sh".to_string(),
            environment: std::collections::HashMap::new(),
            tools: std::collections::HashMap::new(),
        };

        let artifacts = vec![Artifact {
            name: "test-app-binary".to_string(),
            uri: "artifact://test-app-v1.0.0".to_string(),
            hash: "sha256:test123".to_string(),
            size: 2048,
            signature: None,
            sbom: None,
            is_signed: false,
            created: 0,
        }];
        
        let build = manager.create_build("123", source, build_config, artifacts).unwrap();
        manager.store_build(build.clone()).unwrap();
        
        // Perform a security scan
        manager.perform_security_scan(&build.id, "sast").unwrap();
        
        // Record test results
        manager.record_test_results(&build.id, "unit", 100, 100, 0, 95.0).unwrap();
        
        // Evaluate policies
        let result = manager.evaluate_policies(&build.id).unwrap();
        assert!(result); // Should pass with default policies
        
        // Check statistics
        let (total, blocked, scans, tests) = manager.get_cicd_stats();
        assert_eq!(total, 1); // One build processed
        assert_eq!(blocked, 0); // No builds blocked
        assert_eq!(scans, 1); // One security scan performed
        assert_eq!(tests, 1); // One test executed
    }

    #[test]
    fn test_build_blocking_by_policy() {
        let mut manager = SupplyChainManager::new();
        
        let source = SourceInfo {
use std::collections::HashMap;

#[derive(Debug, Clone)]
struct SourceInfo {
    repo_url: String,
    commit_hash: String,
    branch: String,
    tag: Option<String>,
}

#[derive(Debug, Clone)]
struct BuildConfig {
    build_script: String,
    environment: HashMap<String, String>,
    tools: HashMap<String, String>,
}

#[derive(Debug, Clone)]
struct Artifact {
    name: String,
    uri: String,
    hash: String,
    size: u64,
    signature: Option<String>,
    sbom: Option<String>,
    is_signed: bool,
    created: u64,
}

#[derive(Debug, Clone)]
struct Vulnerability {
    id: String,
    severity: f64,
    description: String,
    fix_available: bool,
}

#[derive(Debug, Clone)]
struct SecurityScanResult {
    id: String,
    build_id: String,
    scan_type: String,
    vulnerabilities: Vec<Vulnerability>,
    licenses: Vec<String>,
    completed: u64,
    passed: bool,
}

#[derive(Debug, Clone)]
struct Build {
    id: String,
    source: SourceInfo,
    config: BuildConfig,
    artifacts: Vec<Artifact>,
    passed_policies: bool,
}

struct SupplyChainManager {
    builds: HashMap<String, Build>,
    security_scans: HashMap<String, SecurityScanResult>,
    test_results: HashMap<String, HashMap<String, (u64, u64, u64, f64)>>,
}

impl SupplyChainManager {
    fn new() -> Self {
        SupplyChainManager {
            builds: HashMap::new(),
            security_scans: HashMap::new(),
            test_results: HashMap::new(),
        }
    }

    fn create_build(
        &self,
        id: &str,
        source: SourceInfo,
        config: BuildConfig,
        artifacts: Vec<Artifact>,
    ) -> Result<Build, String> {
        Ok(Build {
            id: id.to_string(),
            source,
            config,
            artifacts,
            passed_policies: false,
        })
    }

    fn store_build(&mut self, build: Build) -> Result<(), String> {
        self.builds.insert(build.id.clone(), build);
        Ok(())
    }

    fn record_test_results(
        &mut self,
        build_id: &str,
        test_type: &str,
        total: u64,
        passed: u64,
        failed: u64,
        coverage: f64,
    ) -> Result<(), String> {
        let results = self.test_results.entry(build_id.to_string()).or_insert_with(HashMap::new);
        results.insert(test_type.to_string(), (total, passed, failed, coverage));
        Ok(())
    }

    fn evaluate_policies(&self, build_id: &str) -> Result<bool, String> {
        let build = self.builds.get(build_id).ok_or("Build not found")?;
        let scans = build
            .artifacts
            .iter()
            .flat_map(|artifact| {
                self.security_scans
                    .values()
                    .filter(|scan| scan.build_id == build.id && scan.artifacts.contains(&artifact.name))
            })
            .collect::<Vec<_>>();

        let has_critical_vulnerability = scans.iter().any(|scan| {
            scan.vulnerabilities.iter().any(|vuln| vuln.severity >= 9.0)
        });

        if has_critical_vulnerability {
            Ok(false)
        } else {
            Ok(true)
        }
    }

    fn get_build(&self, build_id: &str) -> Result<Build, String> {
        self.builds.get(build_id).cloned().ok_or("Build not found")
    }

    fn current_timestamp(&self) -> u64 {
        1633072800 // Example timestamp
    }

    fn get_cicd_stats(&self) -> (usize, usize, usize, usize) {
        let total = self.builds.len();
        let blocked = self.builds.values().filter(|build| !build.passed_policies).count();
        let scans = self.security_scans.len();
        let tests = self.test_results.len();
        (total, blocked, scans, tests)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_build_blocking_by_policy() {
        let mut manager = SupplyChainManager::new();
        
        let source = SourceInfo {
            repo_url: "https://github.com/example/test-app".to_string(),
            commit_hash: "a1b2c3d4e5f".to_string(),
            branch: "main".to_string(),
            tag: Some("v1.0.0".to_string()),
        };

        let build_config = BuildConfig {
            build_script: "build.sh".to_string(),
            environment: std::collections::HashMap::new(),
            tools: std::collections::HashMap::new(),
        };

        let artifacts = vec![Artifact {
            name: "test-app-binary".to_string(),
            uri: "artifact://test-app-v1.0.0".to_string(),
            hash: "sha256:test123".to_string(),
            size: 2048,
            signature: None,
            sbom: None,
            is_signed: false,
            created: 0,
        }];
        
        let build = manager.create_build("123", source, build_config, artifacts).unwrap();
        manager.store_build(build.clone()).unwrap();
        
        // Add a critical vulnerability to trigger policy failure
        let critical_vuln = Vulnerability {
            id: "CVE-2023-99999".to_string(),
            severity: 9.5,
            description: "Critical vulnerability".to_string(),
            fix_available: false,
        };
        
        let scan_id = format!("scan-{}-{}", build.id, manager.current_timestamp());
        let critical_scan = SecurityScanResult {
            id: scan_id,
            build_id: build.id.clone(),
            scan_type: "sast".to_string(),
            vulnerabilities: vec![critical_vuln],
            licenses: vec!["MIT".to_string()],
            completed: manager.current_timestamp(),
            passed: false,
        };
        
        manager.security_scans.insert(critical_scan.id.clone(), critical_scan);
        
        // Record test results
        manager.record_test_results(&build.id, "unit", 100, 100, 0, 95.0).unwrap();
        
        // Evaluate policies - should fail due to critical vulnerability
        let result = manager.evaluate_policies(&build.id).unwrap();
        assert!(!result); // Should fail due to critical vulnerability
        
        // Check that the build was blocked
        let updated_build = manager.get_build(&build.id).unwrap();
        assert!(!updated_build.passed_policies);
        
        // Check statistics
        let (total, blocked, scans, tests) = manager.get_cicd_stats();
        assert_eq!(total, 1); // One build processed
        assert_eq!(blocked, 1); // One build blocked
        assert_eq!(scans, 1); // One security scan performed
        assert_eq!(tests, 1); // One test executed
    }
}
