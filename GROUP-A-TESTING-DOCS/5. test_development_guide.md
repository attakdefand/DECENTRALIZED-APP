# Group A - Test Development Guide

This guide provides instructions for developing new tests for Group A domains, following the project's testing standards and best practices.

## Test Development Standards

### File Naming Convention
- Use PascalCase for test contract names (e.g., `LogicPatternsTest.sol`)
- Suffix test files with `Test.sol` (e.g., `MathSafetyTest.sol`)
- Place test files in `contracts/test/core/` directory

### Test Structure
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
// Other imports

/// @title TestContractName
/// @notice Brief description of what is being tested
contract TestContractName is Test {
    // State variables for testing
    
    /// @notice Set up test environment
    function setUp() public {
        // Initialize contracts and state
    }
    
    // ==================== Test Category ====================
    
    /// @notice Test description
    function testTestName() public {
        // Arrange - Set up test conditions
        // Act - Execute the function being tested
        // Assert - Verify the expected outcome
    }
    
    /// @notice Property test description
    function testPropertyTestName(uint256 parameter) public {
        // Bound parameters to reasonable ranges
        parameter = bound(parameter, min, max);
        
        // Test the property
        // Assert the invariant
    }
}
```

## Writing Unit Tests

### Basic Unit Test Template
```solidity
/// @notice Test CEI pattern in token transfer
function testTokenTransferCEI() public {
    // Arrange
    uint256 initialBalance = token.balanceOf(user1);
    uint256 transferAmount = 1000 * 10**18;
    
    // Act
    vm.prank(user1);
    bool success = token.transfer(user2, transferAmount);
    
    // Assert
    assertTrue(success);
    assertEq(token.balanceOf(user1), initialBalance - transferAmount);
    assertEq(token.balanceOf(user2), transferAmount);
}
```

### Testing Reverts
```solidity
/// @notice Test input bounds validation
function testTokenInputBounds() public {
    // Test that a function reverts with expected message
    vm.expectRevert("Transfer to zero address");
    vm.prank(user1);
    token.transfer(address(0), 1000 * 10**18);
}
```

## Writing Property-Based Tests

### Property Test Template
```solidity
/// @notice Property test: Token balances should always be non-negative
function testPropertyTokenBalancesNonNegative(address user, uint256 amount) public {
    // Bound the parameters to prevent overflow
    amount = bound(amount, 0, 100000 * 10**18);
    
    // Ensure user has enough tokens
    if (token.balanceOf(owner) >= amount && amount > 0) {
        token.transfer(user, amount);
        assertTrue(token.balanceOf(user) >= 0);
    }
}
```

## Writing Invariant Tests

### Invariant Test Contract Structure
```solidity
/// @title InvariantTests
/// @notice Tests for protocol invariants
contract InvariantTests is Test {
    // Target contract
    // Handler contracts
    
    function setUp() public {
        // Deploy target contract
        // Deploy handler contracts
        // Setup initial state
    }
    
    /// @notice Handler for invariant testing
    function invariantTotalSupply() public {
        assertEq(token.totalSupply(), expectedTotalSupply);
    }
}
```

## Testing Best Practices

### 1. Use Descriptive Test Names
```solidity
// Good
function testTokenTransferMaintainsTotalSupply() public {}

// Bad
function testTransfer() public {}
```

### 2. Follow the AAA Pattern
- **Arrange**: Set up the test conditions
- **Act**: Execute the function being tested
- **Assert**: Verify the expected outcome

### 3. Use Appropriate Assertions
```solidity
// Equality
assertEq(actual, expected);

// Boolean
assertTrue(condition);
assertFalse(condition);

// Approximate equality (for floating point)
assertApproxEqAbs(actual, expected, tolerance);
assertApproxEqRel(actual, expected, tolerance);
```

### 4. Handle Edge Cases
```solidity
/// @notice Test behavior with zero amounts
function testEdgeCaseZeroAmounts() public {
    vm.expectRevert("Amount must be positive");
    contract.function(0);
}
```

### 5. Use Parameter Binding
```solidity
/// @notice Property test with bounded parameters
function testPropertyWithBounds(uint256 amount) public {
    amount = bound(amount, 1, 1000000 * 1e18);
    // Test logic
}
```

## Testing Security Patterns

### 1. Reentrancy Guards
```solidity
/// @notice Test reentrancy protection
function testReentrancyGuard() public {
    // Test that reentrant calls are blocked
    vm.expectRevert("ReentrancyGuard: reentrant call");
    maliciousContract.attack();
}
```

### 2. Access Control
```solidity
/// @notice Test onlyOwner modifier
function testOnlyOwnerModifier() public {
    vm.expectRevert("Ownable: caller is not the owner");
    vm.prank(nonOwner);
    contract.ownerOnlyFunction();
}
```

### 3. Input Validation
```solidity
/// @notice Test input bounds
function testInputBounds() public {
    vm.expectRevert("Amount too large");
    contract.function(type(uint256).max);
}
```

## Testing Mathematical Safety

### 1. Overflow Protection
```solidity
/// @notice Test overflow protection
function testOverflowProtection() public {
    // With Solidity 0.8+, overflow reverts automatically
    vm.expectRevert();
    uint256 result = type(uint256).max + 1;
}
```

### 2. Precision Handling
```solidity
/// @notice Test fixed-point arithmetic
function testFixedPointPrecision() public {
    uint256 value = 100 * 1e18; // 100 with 18 decimals
    uint256 multiplier = 5 * 1e18; // 5.0
    uint256 precision = 1e18;
    
    uint256 result = (value * multiplier) / precision;
    assertEq(result, 500 * 1e18); // Should be 500
}
```

## Testing Upgradeability

### 1. Storage Layout
```solidity
/// @notice Test storage layout compatibility
function testStorageLayoutCompatibility() public {
    // Deploy V1
    // Deploy V2
    // Verify storage slots match
}
```

### 2. Upgrade Process
```solidity
/// @notice Test upgrade functionality
function testUpgradeProcess() public {
    // Deploy implementation V1
    // Deploy proxy
    // Upgrade to V2
    // Verify functionality
}
```

## Documentation Standards

### 1. Test Contract Documentation
```solidity
/// @title LogicPatternsTest
/// @notice Comprehensive tests for smart contract logic patterns including CEI, reentrancy guards, and access control
contract LogicPatternsTest is Test {
```

### 2. Test Function Documentation
```solidity
/// @notice Test CEI pattern in token transfer (Checks-Effects-Interactions)
function testCEIPatternInTokenTransfer() public {
```

### 3. Complex Test Documentation
```solidity
/// @notice Property test: Token transfers preserve total supply
/// @param amount The amount to transfer
function testPropertyTokenTransfersPreserveTotalSupply(uint256 amount) public {
    // Bound the amount to prevent overflow and ensure sufficient balance
    amount = bound(amount, 0, token.balanceOf(user1));
    
    // Implementation details...
}
```

## Test Coverage Requirements

### Minimum Coverage
- All public functions: 100%
- All branches: 100%
- All events: 100%
- All error conditions: 100%

### Invariant Coverage
- State invariants must be tested
- Mathematical invariants must be verified
- Protocol invariants must be maintained

### Edge Case Coverage
- Zero values
- Maximum values
- Boundary conditions
- Invalid inputs
- Race conditions

## Continuous Integration

### Test Execution
1. All new tests must pass before merging
2. No test regressions allowed
3. Gas consumption must be within acceptable limits
4. Static analysis must show no new critical issues

### Code Review
1. Test coverage must be adequate
2. Test quality must be high
3. Test documentation must be clear
4. Edge cases must be considered